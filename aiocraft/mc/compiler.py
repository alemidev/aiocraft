#!/usr/bin/env python
import os
import json
import keyword

from typing import List, Dict

from mctypes import *

DIR_MAP = {"toClient": "clientbound", "toServer": "serverbound"}
PREFACE = """\"\"\"[!] This file is autogenerated\"\"\"\n\n"""
IMPORTS = """from typing import Tuple
from ....packet import Packet
from ....mctypes import *\n"""
IMPORT_ALL = """__all__ = [\n\t{all}\n]\n"""
OBJECT = """
class {name}(Packet):
	id : int = 0x{id:X}
	_slots : Tuple[Tuple[str, Type]] = (
		{slots}
	)
	{fields}
"""

TYPE_MAP = {
	"varint": VarInt,
	"u8": UnsignedShort,
	"u16": UnsignedInt,
	"u32": UnsignedLong,
	"i16": Short,
	"i32": Int,
	"i64": Long,
	"f32": Float,
	"f64": Double,
	"bool": Boolean,
	"UUID": UUID,
	"string": String,
	"nbt": NBTTag,
	"slot": Slot,
	"position": Position,
	"entityMetadataItem": EntityMetadataItem,
	"entityMetadata": EntityMetadata,
}

def mctype(name:str) -> Type:
	if not isinstance(name, str):
		return String # should return TrailingByteArray but still haven't implemented it (:
	if name in TYPE_MAP:
		return TYPE_MAP[name]
	return String # should return TrailingByteArray but still haven't implemented it (:

def snake_to_camel(name:str) -> str:
	return "".join(x.capitalize() for x in name.split("_"))

def parse_slot(slot: dict) -> str:
	name = slot["name"] if "name" in slot else "anon"
	if keyword.iskeyword(name):
		name = "is_" + name
	t = mctype(slot["type"] if "type" in slot else "restBuffer")
	return f"(\"{name}\", {t.__name__})"

def parse_field(slot: dict) -> str:
	name = slot["name"] if "name" in slot else "anon"
	if keyword.iskeyword(name):
		name = "is_" + name
	t = mctype(slot["type"] if "type" in slot else "restBuffer")
	return f"{name} : {t._pytype.__name__}"

class PacketClassWriter:
	pid   : int
	title : str
	slots : List[Dict[str, str]]

	def __init__(self, pid:int, title:str, slots:List[Dict[str, str]]):
		self.pid = pid
		self.title = title
		self.slots = slots

	def compile(self) -> str:
		return PREFACE + \
			IMPORTS + \
			OBJECT.format(
				id=pid, 
				name=self.title, 
				slots=",\n\t\t".join(parse_slot(slot) for slot in self.slots),
				fields="\n\t".join(parse_field(slot) for slot in self.slots),
			)

def _make_module(path:str, contents:dict):
	os.mkdir(path)
	if not path.endswith("/"):
		path += "/"
	imports = ""
	for key in contents:
		imports += f"from .{key} import {contents[key]}\n"
	with open(path + "__init__.py", "w") as f:
		f.write(PREFACE + imports)

if __name__ == "__main__":
	# TODO load relatively!
	with open("/home/alemi/projects/minecraft-data/data/pc/1.12.2/protocol.json") as f:
		data = json.load(f)

	# TODO get the `minecraft` folder
	_make_module("proto", {"handshaking":"*", "status":"*", "login":"*", "play":"*"})
	for state in ("handshaking", "status", "login", "play"):
		_make_module(f"proto/{state}", {"clientbound":"*", "serverbound":"*"})
		for _direction in ("toClient", "toServer"):
			direction = DIR_MAP[_direction]
			buf = data[state][_direction]["types"]["packet"][1][0]["type"][1]["mappings"]
			registry = { f"packet_{value}" : int(key, 16) for (key, value) in buf.items() }
			contents = { key : snake_to_camel(key) for key in data[state][_direction]["types"].keys() if key != "packet" }
			_make_module(f"proto/{state}/{direction}", contents)
			for p_name in data[state][_direction]["types"].keys():
				if p_name == "packet":
					continue # it's the registry entry
				packet = data[state][_direction]["types"][p_name]
				pid = registry[p_name]
				class_name = snake_to_camel(p_name)
				with open(f"proto/{state}/{direction}/{p_name}.py", "w") as f:
					f.write(PacketClassWriter(pid, class_name, packet[1]).compile())



